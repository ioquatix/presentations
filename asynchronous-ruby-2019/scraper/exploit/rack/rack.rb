#!/usr/bin/env ruby

require 'rack/session/pool'

# This just increases the chance of a collision.
module Rack
	module Session
		class Abstract::Persisted
			def generate_sid
				rand(2**16).to_s(16)
			end
		end
	end
end

store = Rack::Session::Pool.new(lambda{|env| env['rack.session'][:msg] = "Hello Rack"; [200, {}, []]}, renew: true)
pool = store.instance_variable_get(:@pool)

request = Rack::Request.new({
	'rack.multithread' => true
})

response = store.call(request.env)

pp response

# session_data = {"oh" => "my!"}
# 
# threads = []
# 
# mutex = Mutex.new
# 
# 1000.times do
# 	threads << Thread.new do
# 		while true
# 			# This replicates the essential parts of Persisted#commit_session
# 			request = Rack::Request.new({
# 				'rack.multithread' => true
# 			})
# 
# 			session = Rack::Session::Abstract::SessionHash.new(store, request)
# 			options = session.options
# 
# 			sid = store.generate_sid
# 
# 			session_id = store.delete_session(request, sid, options)
# 
# 			if pool.key?(session_id)
# 				puts "Generated SID #{sid} was already used!"
# 			end
# 
# 			store.write_session(request, session_id, session_data, options)
# 
# 			unless pool.key?(session_id)
# 				puts "Generated SID #{sid} was deleted!"
# 			end
# 		end
# 	end
# end
# 
# threads.each(&:join)
# 
# # koyoko% ./rack.rb
# # Generated SID f577 was already used!
# # Generated SID b29 was deleted!
# # Generated SID 1eb3 was deleted!
# # Generated SID d2b1 was deleted!
# # Generated SID 6b9e was deleted!
# # ^C%                                                                                                                                                           koyoko% 
# # koyoko% ./rack.rb
# # Generated SID 95b9 was already used!
# # Generated SID 720b was deleted!
